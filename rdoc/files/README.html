<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 17 21:17:16 -0400 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
Grapher
</p>
<h6>=</h6>
<p>
THIS IS PRE-ALPHA SOFTWARE. DON&#8216;T TRY THIS QUITE YET.
</p>
<p>
This plugin lets you store a graph representation of your data in Redis.
(&quot;<a href="../classes/Graph.html">Graph</a>&quot; as in &quot;<a
href="../classes/Graph.html">Graph</a> Theory&quot;, this is NOT charting
sofrtware.)
</p>
<p>
A graph representation of your objects is a very powerful analytical tool
for discovering inter-object relationships that cannot be discovered easily
or nearly as efficiently using a relational database.
</p>
<p>
For more info on Redis see <a href="http://redis.io">redis.io</a>/
</p>
<p>
Introduction
</p>
<h6>======</h6>
<p>
Imagine the following model:
</p>
<p>
User
</p>
<pre>
  has_many :orders
</pre>
<p>
Order
</p>
<pre>
  belongs_to :user
  has_many :items, :through =&gt; order_items
</pre>
<p>
OrderItem
</p>
<pre>
  belongs_to :order
  belongs_to :item, :polymorphic =&gt; true
  has_one :user, :through =&gt; :order
</pre>
<p>
Imagine that you would like to keep track of a user buying an item. You can
get a user&#8216;s orders via user.orders, the for each of those collect
the items. So it&#8216;s possible, but it&#8216;s not a one-step operation.
</p>
<p>
Imagine that you wanted to compare what a user has purchased with what
other users have purchased, so that you could make a recommendation such as
&quot;users who purchased X also purchased Y&quot;. Given the above
database structure it would be a pretty complicated operation.
</p>
<p>
(Bear with us, we&#8216;re getting to the point.)
</p>
<p>
Now imagine that you stored a user&#8216;s purchases in a graph, like this
(numbers are users, letters are items):
</p>
<p>
+&#8212;&gt; D &lt;&#8212;+ | | 1 &#8212;&gt; A &lt;&#8212; 2 &#8212;&gt; B
</p>
<pre>
      ^
      |
      3 --&gt; C &lt;-- 4
</pre>
<p>
In the above graph:
</p>
<p>
user 1 purchased [A, D] user 2 purchased [A, B, D] user 3 purchased [A, C]
user 4 purchased [C]
</p>
<p>
You can see that users 1 and 2 both purchased items A and D. Based on this
you could say that users 1 and 2 have similar purchasing pattern, and that
item B may be of interest to user 1. You could also say that items A and D
may be related because more than one user purchased them together.
</p>
<p>
You may have noticed that users 1 and 2 are two graph edges away from each
other. Also that there are multiple paths connecting users 1 and 2 (via A
and via D).
</p>
<p>
This means that to find users with similar purchasing pattern, all we need
to do is to enumerate all users exactly two &quot;hops&quot; away. And if
we were to count the number of time we come across the same user, this
count would become a rank of similarity - the higher the rank, the more
similar these users are.
</p>
<p>
Same principle applies to items. Items two edges apart can be deemed
similar, and the more common paths, the higher the degree of similarity.
</p>
<p>
If we were to store the above graph as a two hashes of sets (one for
forward links from user to item, the second for reverse from item to user),
such as (in pseudo-ruby code):
</p>
<p>
forward = { 1 =&gt; {A, D},
</p>
<pre>
            2 =&gt; {A, B, D},
            3 =&gt; {A, C},
            4 =&gt; {C} }
</pre>
<p>
reverse = { A =&gt; {1, 2, 3},
</p>
<pre>
            B =&gt; {2},
            C =&gt; {3, 4},
            D =&gt; {1, 2} }
</pre>
<p>
we could quite easily accomplish the above operation. For example, all
users similar to 1 are:
</p>
<p>
forward[1].each { |item| reverse[item] }
</p>
<p>
Similarly items similar to A would be:
</p>
<p>
reverse[A].each { |user| forward[user] }
</p>
<p>
There is only one remaining problem - if your database is any decent size
by todays standards, building these hashes may take enough CPU/memory to
make it impractical.
</p>
<p>
This is where Redis comes in. We can build this structure once and maintain
it with proper callbacks and keep it stored in Redis. Redis provides all
the basic operations for the above calculations and is fast enough for
these calculations to be performed real-time.
</p>
<p>
Example
</p>
<h6>=</h6>
<p>
class OrderItem &lt; ActiveRecord::Base
</p>
<pre>
  belongs_to :order
  belongs_to :item, :polymorphic =&gt; true
  has_one :user, :through =&gt; :order
  graph_edge_from :user, :to =&gt; :item, :on =&gt; :create, :verb =&gt; 'Purchased'
  ...
</pre>
<p>
class User &lt; ActiveRecord::Base
</p>
<pre>
  has_many :orders
  graph_node :verbs =&gt; '&gt;Purchased'
</pre>
<p>
&gt;&gt; u = User.find(:first) &gt;&gt; u.graph_neighbors
</p>
<h1>&gt; #&lt;Set: {&quot;Item:234&quot;, &quot;Item:345&quot;, &quot;Item:456&quot;}&gt;</h1>
<p>
&gt;&gt; u.graph_neighbors(:distance =&gt; 2)
</p>
<h1>&gt; #&lt;Set: {&quot;User:12&quot;, &quot;User:23&quot;, &quot;User:2345&quot;}&gt;</h1>
<p>
&gt;&gt; u.graph_neighbors_ranked(:distance =&gt; 2)
</p>
<h1>&gt; [[9, &quot;User:23&quot;], [5, &quot;User:23&quot;], [1, &quot;User:2345&quot;]]</h1>
<p>
Copyright (c) 2011 Tournesol Ventures, LLC
</p>
<pre>
   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</pre>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>